---
title: "Gene Co-Expression Network Analysis"
subtitle: "BIO512 Transcriptomics – Network Construction and Clustering Analysis"
author: "Muhammad Arif"
date: November 10, 2025
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: false
    theme:
      light: cosmo
      dark: darkly
---

# Introduction

In this practical, we will construct (or load) a gene co-expression network from normalized RNA-seq counts and analyze its topology. You will compute centrality measures, detect modules via Leiden clustering, and perform functional enrichment on selected clusters.

::: {.callout-important}
## Setup Instructions
```bash
mkdir -p ~/BIO512/Network_analysis
cd ~/BIO512/Network_analysis

# Required files can be fetched from the Cluster
scp -r <your_vera_username>@vera2.chalmers.se:/cephyr/NOBACKUP/groups/n2bin_gu/BIO512/Network_analysis/* ~/BIO512/Network_analysis/

# Remember to activate the conda environment
conda activate BIO512_v1
# Launch Jupyter Lab or run the notebook in VScode

# For any excersise that has a {__}, this is a placeholder that you need to fill in with appropriate code.
myvariable = {__}
# should be replaced with actual code.
myvariable = "Hello, World!"
```
:::

---

# (Optional) Network construction from normalized counts

This step is optional because I have generated the pre-calculated network based on the our Leishmania data. **We will focus more on the downstream analysis in this lab**. I would suggest you to go through the "coexpression_generation" function above to learn more about the detailed process. This function was taken from the pipeline used in this this paper:
https://pubmed.ncbi.nlm.nih.gov/37038090/

If you want to do this step yourself, there is an additional instruction at the bottom of the practical

---

# Load network and visualize in iGraph

1. Load the co-expression network dataframe

```python
coexp_network = pd.read_csv("coexpression_network.txt", sep = "\t")
```

2. Load the dataframe into the iGraph.

```python
g = ig.Graph.TupleList(zip(coexp_network['level_0'],coexp_network['level_1']))
```

::: {.callout-note}
Network can be visualized using the iGraph built-in functions. In order to make a neat layout, we can select different layout options.

In this lab, we let igraph deciding the most suitable layout (auto), but there are many other options Read below:
https://igraph.org/python/tutorial/0.9.6/visualisation.html
:::

```python
layout = g.layout(layout='auto')

fig, ax = plt.subplots() ## We are using matplotlib for the visualization, otherwise there are many other requirements to install
ig.plot(
    g,
    layout = layout,
    target=ax, # this option is to attach the plot to matplotlib
)

fig.set_size_inches(20, 20) # defining the size of the canvas
```

## Questions

- **Q1: How many nodes and edges?**
- **Q2: Network diameter and density? Interpret their meaning.**

```python
g.vcount()
```
```python
g.ecount()
```
```python
g.diameter()
```
```python
g.density()

```

---

# Centrality analysis

Centrality measures help identify important or influential genes within a co-expression network. 
Different measures capture different aspects of "importance":

- Degree Centrality: Number of direct connections a gene has. Hub genes often play central biological roles.  
- Betweenness Centrality: How often a gene lies on the shortest paths between other genes. High betweenness genes may act as bridges between modules.  
- Closeness Centrality: How close a gene is to all other genes in the network. Genes with high closeness can quickly influence or be influenced by others.  
- Eigenvector Centrality: Importance of a gene based not only on its connections, but also on the importance of its neighbors.

Read iGraph Python manual https://python.igraph.org/en/stable/

## Questions

::: {.callout-tip}
Hint 1: The output of centrality measures in iGraph Python are lists. To convert to Pandas Series for easy analysis, use `pd.Series(list, index = g.vs["name"])`

Hint 2: Use the Pandas sort_values function to rank the Series https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html
:::

- **Q3: Which genes are hubs (high degree centrality)? (top 10)**  
- **Q4: Which genes act as bridges between modules (high betweenness)? (top 10)**  
- **Q5: Perform Closeness and Eigenvector centrality analysis. Looking at top 40 most central genes for each measurement, is there any intersection between different methods? Which methods are more similar? Why?**  
- **Q6: Compare biological functions of hub vs. bridge genes — do they play different roles? (Hint: Use the Enrichr website or GSEAPY module from DESeq2 lab to identify their functions) https://maayanlab.cloud/Enrichr/**

```python
# Calculate centrality measures
degree_centrality = {__}
betweenness_centrality = {__}
closeness_centrality = {__}
eigenvector_centrality = {__}

# Add centrality values as node attributes
g.vs["degree"] = degree_centrality
g.vs["betweenness"] = betweenness_centrality
g.vs["closeness"] = closeness_centrality
g.vs["eigenvector"] = eigenvector_centrality

# Create a DF to present different centrality analyses
centrality_df = pd.DataFrame({
    "gene": g.vs["name"],
    "degree": degree_centrality,
    "betweenness": betweenness_centrality,
    "closeness": closeness_centrality,
    "eigenvector": eigenvector_centrality
})
```

## Optional: Advance Plotting: Use centrality variables as the node size

```python
fig, ax = plt.subplots() ## We are using matplotlib for the visualization, otherwise there are many other requirements to install
ig.plot(
    g,
    layout = layout,
    target=ax, # this option is to attach the plot to matplotlib
    vertex_size=g.degree(),
)

fig.set_size_inches(20, 20) # defining the size of the canvas
```

---

# Clustering / Module Detection

Gene co-expression networks often show a modular structure, where groups of genes are more strongly connected than to the rest of the network. 
These modules (or clusters) can reveal shared biological functions, pathways, or regulatory programs.

### Common Approaches

- **Community Detection Algorithms:**
  - *Louvain / Leiden*: Partition the network into communities by maximizing modularity.
  - *Walktrap*: Uses random walks to detect densely connected subgraphs.
  - *Fastgreedy*: Greedy optimization of modularity.
- **Hierarchical Clustering:** Applied to adjacency or topological overlap matrices (TOM).
- **WGCNA Modules:** Modules defined via dynamic tree cutting on the TOM.

### Key Concepts

- **Module:** A set of tightly co-expressed genes.
- **Module Eigengene:** The first principal component of a module’s gene expression — represents the overall expression profile of the module.
- **Module Size:** The number of genes in the module; larger modules may represent broad pathways, smaller modules more specific processes.

### Leiden Algorithm
In this lab, we will use the "Leiden" algorithm. To perform Leiden community detection, it is pretty simple. Read about their options and feel free to adjust it

https://igraph.org/python/api/0.9.11/igraph.Graph.html#community_leiden

In the same documentation, you can also learn about other approaches.

```python
clustering = g.community_leiden(objective_function='modularity', n_iterations=-1, resolution=0.2)
```

Cluster membership list is under clustering.membership object. It is a list, so you have to convert them to Series (see above) for easy analysis.

To count the number of members in each clusters (after converted to Series), use ".value_counts()" function in Pandas
https://pandas.pydata.org/docs/reference/api/pandas.Series.value_counts.html


```python
memberships = pd.Series(clustering.membership, index = g.vs["name"])

memberships.head()

cluster_sizes = {__}
cluster_sizes.head()
```

## Questions to Explore

- **Q7: How many modules/clusters can you detect in the network?**
- **Q8: Which module is the largest? Which is the smallest?**
- **Q9: Which modules contain the most hub genes identified earlier?**
- **Q10: If you pick the largest module, what biological function might it represent? Make a visualization of top 10 most enriched processes** 

::: {.callout-tip}
Use the Enrichr website or GSEAPY module from DESeq2 lab to identify their functions: https://maayanlab.cloud/Enrichr/**
:::

- **Q11(OPTIONAL): Can you identify the hub gene(s) in the two biggest modules?**

:::{ .callout-tip}
Slice the original network using .subgraph
:::

---

# Optional: Clustering Graph Visualization

Instead of plotting the graph object (g), we can also plot the clustering object. Adding the option "mark_groups" will allow for unique background color for each cluster.

## Optional Task: Can you identify the clusters with hubs using the plot?

```python
fig, ax = plt.subplots()
ig.plot(
    clustering,
    target=ax,
    layout=layout,
    mark_groups=True,
    #vertex_size=15,
    vertex_size=g.degree(),
)
fig.set_size_inches(20, 20)
```

---

# Additional instructions for network construction (if you have time)
If you want to generate the co-expression network yourself, follow these steps (add into new code cells in the notebook):

## Load normalized count file

In generating gene co-expression network, we use normalized count instead of raw counts. It can be TPM, FPKM, RPKM, or any normalization. For this lab, we are going to use normalized count from the DESeq lab.

```python
norm_count = pd.read_csv("Deseq2_NormalizedCount.txt", sep = "\t", index_col = 0)

# Exclude all-zero genes 
norm_count = norm_count[norm_count.sum(1) > 0]
```

## Generating Gene Co-Expression Network

```python
def coexpression_generation(norm_count,padj_thr=0.05):
    print('Calculating Correlation..')
    temp=spearmanr(norm_count.T)
    corr=pd.DataFrame(temp[0],columns=list(norm_count.index),index=list(norm_count.index))
    pval=pd.DataFrame(temp[1],columns=list(norm_count.index),index=list(norm_count.index))
    print('Filtering the matrix Correlation..')
    corr=corr.where(np.triu(np.ones(corr.shape)).astype(np.bool))
    pval=pval.where(np.triu(np.ones(pval.shape)).astype(np.bool))
    print('Making long table of Correlation..')
    corr2=corr.unstack().reset_index(name='weight')
    pval2=pval.unstack().reset_index(name='pval')
    res=corr2.merge(pval2,on=['level_0','level_1'])
    res=res[res['level_0'] != res['level_1']]
    res=res.dropna()
    print('Adjusting P-val')
    res['padj']=multipletests(res['pval'],method='fdr_bh')[1]
    res=res[res.padj < padj_thr].reset_index(drop=True)
    res=res[['level_0','level_1','weight']]
    print('Done!!')
    return res

coexp_network = coexpression_generation(norm_count)
coexp_network = coexp_network[coexp_network["weight"] > 0]
coexp_network.to_csv("coexpression_network.txt", sep = "\t", index = False)
```

Map to gene names (optional):

```python
# Starting connections to ensembl website using the "Dataset" function from pyBioMart
dataset = Dataset(name='hsapiens_gene_ensembl', host='http://www.ensembl.org')

# Retrieving name mapping dataframe between "Esembl ID" and External Gene Name (HGNC) and focusing only on "protein coding" genes
mapping = dataset.query(attributes=['ensembl_gene_id', 'external_gene_name'])
coexp_network.replace(mapping.set_index("Gene stable ID")["Gene name"]).dropna().to_csv("coexpression_network.txt", sep = "\t", index = False)
```

::: {.callout-note}
The output is a dataframe with 3 columns:

- level_1: gene node 1
- level_2: gene node 2
- weight: correlation score
:::

---

# Things to append to your submission

- Save your notebook as PRACTICAL_NETWORK_ANALYSIS_yourname.ipynb
- Add answers to the questions in separate markdown cells
- Add your code blocks from the jupyter notebook with completed code where the placeholders were 
- Include some output cells with figures (if multiple runs are needed, keep only the last one)

